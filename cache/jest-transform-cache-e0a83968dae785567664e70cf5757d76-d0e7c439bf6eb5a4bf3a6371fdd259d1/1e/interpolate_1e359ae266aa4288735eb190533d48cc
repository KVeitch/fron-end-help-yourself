198d2867a0602a1ca4b9f321ba24c53d
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = interpolate;
exports.Extrapolate = void 0;

var _operators = require("../operators");

var _AnimatedCond = require("../core/AnimatedCond");

var _invariant = _interopRequireDefault(require("fbjs/lib/invariant"));

var _AnimatedNode = _interopRequireDefault(require("../core/AnimatedNode"));

function interpolateInternalSingle(value, inputRange, outputRange, offset) {
  var inS = inputRange[offset];
  var inE = inputRange[offset + 1];
  var outS = outputRange[offset];
  var outE = outputRange[offset + 1];
  var progress = (0, _operators.divide)((0, _operators.sub)(value, inS), (0, _operators.sub)(inE, inS));
  return (0, _operators.add)(outS, (0, _operators.multiply)(progress, (0, _operators.sub)(outE, outS)));
}

function interpolateInternal(value, inputRange, outputRange) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (inputRange.length - offset === 2) {
    return interpolateInternalSingle(value, inputRange, outputRange, offset);
  }

  return (0, _AnimatedCond.createAnimatedCond)((0, _operators.lessThan)(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));
}

var Extrapolate = {
  EXTEND: 'extend',
  CLAMP: 'clamp',
  IDENTITY: 'identity'
};
exports.Extrapolate = Extrapolate;

function checkNonDecreasing(name, arr) {
  for (var i = 1; i < arr.length; ++i) {
    if (arr[i] instanceof _AnimatedNode.default || arr[i - 1] instanceof _AnimatedNode.default) continue;
    (0, _invariant.default)(arr[i] >= arr[i - 1], '%s must be monotonically non-decreasing. (%s)', name, arr);
  }
}

function checkMinElements(name, arr) {
  (0, _invariant.default)(arr.length >= 2, '%s must have at least 2 elements. (%s)', name, arr);
}

function checkValidNumbers(name, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] instanceof _AnimatedNode.default) continue;
    (0, _invariant.default)(Number.isFinite(arr[i]), '%s cannot include %s. (%s)', name, arr[i], arr);
  }
}

function interpolate(value, config) {
  var inputRange = config.inputRange,
      outputRange = config.outputRange,
      _config$extrapolate = config.extrapolate,
      extrapolate = _config$extrapolate === void 0 ? Extrapolate.EXTEND : _config$extrapolate,
      extrapolateLeft = config.extrapolateLeft,
      extrapolateRight = config.extrapolateRight;
  checkMinElements('inputRange', inputRange);
  checkValidNumbers('inputRange', inputRange);
  checkMinElements('outputRange', outputRange);
  checkValidNumbers('outputRange', outputRange);
  checkNonDecreasing('inputRange', inputRange);
  (0, _invariant.default)(inputRange.length === outputRange.length, 'inputRange and outputRange must be the same length.');
  var left = extrapolateLeft || extrapolate;
  var right = extrapolateRight || extrapolate;
  var output = interpolateInternal(value, inputRange, outputRange);

  if (left === Extrapolate.EXTEND) {} else if (left === Extrapolate.CLAMP) {
    output = (0, _AnimatedCond.createAnimatedCond)((0, _operators.lessThan)(value, inputRange[0]), outputRange[0], output);
  } else if (left === Extrapolate.IDENTITY) {
    output = (0, _AnimatedCond.createAnimatedCond)((0, _operators.lessThan)(value, inputRange[0]), value, output);
  }

  if (right === Extrapolate.EXTEND) {} else if (right === Extrapolate.CLAMP) {
    output = (0, _AnimatedCond.createAnimatedCond)((0, _operators.greaterThan)(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);
  } else if (right === Extrapolate.IDENTITY) {
    output = (0, _AnimatedCond.createAnimatedCond)((0, _operators.greaterThan)(value, inputRange[inputRange.length - 1]), value, output);
  }

  return output;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImludGVycG9sYXRlLmpzIl0sIm5hbWVzIjpbImludGVycG9sYXRlSW50ZXJuYWxTaW5nbGUiLCJ2YWx1ZSIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsIm9mZnNldCIsImluUyIsImluRSIsIm91dFMiLCJvdXRFIiwicHJvZ3Jlc3MiLCJpbnRlcnBvbGF0ZUludGVybmFsIiwibGVuZ3RoIiwiRXh0cmFwb2xhdGUiLCJFWFRFTkQiLCJDTEFNUCIsIklERU5USVRZIiwiY2hlY2tOb25EZWNyZWFzaW5nIiwibmFtZSIsImFyciIsImkiLCJBbmltYXRlZE5vZGUiLCJjaGVja01pbkVsZW1lbnRzIiwiY2hlY2tWYWxpZE51bWJlcnMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImludGVycG9sYXRlIiwiY29uZmlnIiwiZXh0cmFwb2xhdGUiLCJleHRyYXBvbGF0ZUxlZnQiLCJleHRyYXBvbGF0ZVJpZ2h0IiwibGVmdCIsInJpZ2h0Iiwib3V0cHV0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQVNBOztBQUNBOztBQUNBOztBQUVBLFNBQVNBLHlCQUFULENBQW1DQyxLQUFuQyxFQUEwQ0MsVUFBMUMsRUFBc0RDLFdBQXRELEVBQW1FQyxNQUFuRSxFQUEyRTtBQUN6RSxNQUFNQyxHQUFHLEdBQUdILFVBQVUsQ0FBQ0UsTUFBRCxDQUF0QjtBQUNBLE1BQU1FLEdBQUcsR0FBR0osVUFBVSxDQUFDRSxNQUFNLEdBQUcsQ0FBVixDQUF0QjtBQUNBLE1BQU1HLElBQUksR0FBR0osV0FBVyxDQUFDQyxNQUFELENBQXhCO0FBQ0EsTUFBTUksSUFBSSxHQUFHTCxXQUFXLENBQUNDLE1BQU0sR0FBRyxDQUFWLENBQXhCO0FBQ0EsTUFBTUssUUFBUSxHQUFHLHVCQUFPLG9CQUFJUixLQUFKLEVBQVdJLEdBQVgsQ0FBUCxFQUF3QixvQkFBSUMsR0FBSixFQUFTRCxHQUFULENBQXhCLENBQWpCO0FBQ0EsU0FBTyxvQkFBSUUsSUFBSixFQUFVLHlCQUFTRSxRQUFULEVBQW1C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dENrQixJQUFBQSxNQUFNLEdBQUcsc0NBQ1AsNEJBQVkvQixLQUFaLEVBQW1CQyxVQUFVLENBQUNBLFVBQVUsQ0FBQ1MsTUFBWCxHQUFvQixDQUFyQixDQUE3QixDQURPLEVBRVBSLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDUSxNQUFaLEdBQXFCLENBQXRCLENBRkosRUFHUHFCLE1BSE8sQ0FBVDtBQUtELEdBTk0sTUFNQSxJQUFJRCxLQUFLLEtBQUtuQixXQUFXLENBQUNHLFFBQTFCLEVBQW9DO0FBQ3pDaUIsSUFBQUEsTUFBTSxHQUFHLHNDQUNQLDRCQUFZL0IsS0FBWixFQUFtQkMsVUFBVSxDQUFDQSxVQUFVLENBQUNTLE1BQVgsR0FBb0IsQ0FBckIsQ0FBN0IsQ0FETyxFQUVQVixLQUZPLEVBR1ArQixNQUhPLENBQVQ7QUFLRDs7QUFFRCxTQUFPQSxNQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBsZXNzVGhhbixcbiAgbXVsdGlwbHksXG4gIHN1YixcbiAgYWRkLFxuICBkaXZpZGUsXG4gIGdyZWF0ZXJUaGFuLFxufSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBjcmVhdGVBbmltYXRlZENvbmQgYXMgY29uZCB9IGZyb20gJy4uL2NvcmUvQW5pbWF0ZWRDb25kJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnZmJqcy9saWIvaW52YXJpYW50JztcbmltcG9ydCBBbmltYXRlZE5vZGUgZnJvbSAnLi4vY29yZS9BbmltYXRlZE5vZGUnO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUludGVybmFsU2luZ2xlKHZhbHVlLCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGluUyA9IGlucHV0UmFuZ2Vbb2Zmc2V0XTtcbiAgY29uc3QgaW5FID0gaW5wdXRSYW5nZVtvZmZzZXQgKyAxXTtcbiAgY29uc3Qgb3V0UyA9IG91dHB1dFJhbmdlW29mZnNldF07XG4gIGNvbnN0IG91dEUgPSBvdXRwdXRSYW5nZVtvZmZzZXQgKyAxXTtcbiAgY29uc3QgcHJvZ3Jlc3MgPSBkaXZpZGUoc3ViKHZhbHVlLCBpblMpLCBzdWIoaW5FLCBpblMpKTtcbiAgcmV0dXJuIGFkZChvdXRTLCBtdWx0aXBseShwcm9ncmVzcywgc3ViKG91dEUsIG91dFMpKSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlSW50ZXJuYWwodmFsdWUsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChpbnB1dFJhbmdlLmxlbmd0aCAtIG9mZnNldCA9PT0gMikge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZUludGVybmFsU2luZ2xlKHZhbHVlLCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gY29uZChcbiAgICBsZXNzVGhhbih2YWx1ZSwgaW5wdXRSYW5nZVtvZmZzZXQgKyAxXSksXG4gICAgaW50ZXJwb2xhdGVJbnRlcm5hbFNpbmdsZSh2YWx1ZSwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9mZnNldCksXG4gICAgaW50ZXJwb2xhdGVJbnRlcm5hbCh2YWx1ZSwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9mZnNldCArIDEpXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBFeHRyYXBvbGF0ZSA9IHtcbiAgRVhURU5EOiAnZXh0ZW5kJyxcbiAgQ0xBTVA6ICdjbGFtcCcsXG4gIElERU5USVRZOiAnaWRlbnRpdHknLFxufTtcblxuZnVuY3Rpb24gY2hlY2tOb25EZWNyZWFzaW5nKG5hbWUsIGFycikge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIC8vIFdlIGNhbid0IHZhbGlkYXRlIGFuaW1hdGVkIG5vZGVzIGluIEpTLlxuICAgIGlmIChhcnJbaV0gaW5zdGFuY2VvZiBBbmltYXRlZE5vZGUgfHwgYXJyW2kgLSAxXSBpbnN0YW5jZW9mIEFuaW1hdGVkTm9kZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGludmFyaWFudChcbiAgICAgIGFycltpXSA+PSBhcnJbaSAtIDFdLFxuICAgICAgJyVzIG11c3QgYmUgbW9ub3RvbmljYWxseSBub24tZGVjcmVhc2luZy4gKCVzKScsXG4gICAgICBuYW1lLFxuICAgICAgYXJyXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja01pbkVsZW1lbnRzKG5hbWUsIGFycikge1xuICBpbnZhcmlhbnQoXG4gICAgYXJyLmxlbmd0aCA+PSAyLFxuICAgICclcyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBlbGVtZW50cy4gKCVzKScsXG4gICAgbmFtZSxcbiAgICBhcnJcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZE51bWJlcnMobmFtZSwgYXJyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gV2UgY2FuJ3QgdmFsaWRhdGUgYW5pbWF0ZWQgbm9kZXMgaW4gSlMuXG4gICAgaWYgKGFycltpXSBpbnN0YW5jZW9mIEFuaW1hdGVkTm9kZSkgY29udGludWU7XG4gICAgaW52YXJpYW50KFxuICAgICAgTnVtYmVyLmlzRmluaXRlKGFycltpXSksXG4gICAgICAnJXMgY2Fubm90IGluY2x1ZGUgJXMuICglcyknLFxuICAgICAgbmFtZSxcbiAgICAgIGFycltpXSxcbiAgICAgIGFyclxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW50ZXJwb2xhdGUodmFsdWUsIGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgaW5wdXRSYW5nZSxcbiAgICBvdXRwdXRSYW5nZSxcbiAgICBleHRyYXBvbGF0ZSA9IEV4dHJhcG9sYXRlLkVYVEVORCxcbiAgICBleHRyYXBvbGF0ZUxlZnQsXG4gICAgZXh0cmFwb2xhdGVSaWdodCxcbiAgfSA9IGNvbmZpZztcbiAgY2hlY2tNaW5FbGVtZW50cygnaW5wdXRSYW5nZScsIGlucHV0UmFuZ2UpO1xuICBjaGVja1ZhbGlkTnVtYmVycygnaW5wdXRSYW5nZScsIGlucHV0UmFuZ2UpO1xuICBjaGVja01pbkVsZW1lbnRzKCdvdXRwdXRSYW5nZScsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZE51bWJlcnMoJ291dHB1dFJhbmdlJywgb3V0cHV0UmFuZ2UpO1xuICBjaGVja05vbkRlY3JlYXNpbmcoJ2lucHV0UmFuZ2UnLCBpbnB1dFJhbmdlKTtcbiAgaW52YXJpYW50KFxuICAgIGlucHV0UmFuZ2UubGVuZ3RoID09PSBvdXRwdXRSYW5nZS5sZW5ndGgsXG4gICAgJ2lucHV0UmFuZ2UgYW5kIG91dHB1dFJhbmdlIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoLidcbiAgKTtcblxuICBjb25zdCBsZWZ0ID0gZXh0cmFwb2xhdGVMZWZ0IHx8IGV4dHJhcG9sYXRlO1xuICBjb25zdCByaWdodCA9IGV4dHJhcG9sYXRlUmlnaHQgfHwgZXh0cmFwb2xhdGU7XG4gIGxldCBvdXRwdXQgPSBpbnRlcnBvbGF0ZUludGVybmFsKHZhbHVlLCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSk7XG5cbiAgaWYgKGxlZnQgPT09IEV4dHJhcG9sYXRlLkVYVEVORCkge1xuICB9IGVsc2UgaWYgKGxlZnQgPT09IEV4dHJhcG9sYXRlLkNMQU1QKSB7XG4gICAgb3V0cHV0ID0gY29uZChsZXNzVGhhbih2YWx1ZSwgaW5wdXRSYW5nZVswXSksIG91dHB1dFJhbmdlWzBdLCBvdXRwdXQpO1xuICB9IGVsc2UgaWYgKGxlZnQgPT09IEV4dHJhcG9sYXRlLklERU5USVRZKSB7XG4gICAgb3V0cHV0ID0gY29uZChsZXNzVGhhbih2YWx1ZSwgaW5wdXRSYW5nZVswXSksIHZhbHVlLCBvdXRwdXQpO1xuICB9XG5cbiAgaWYgKHJpZ2h0ID09PSBFeHRyYXBvbGF0ZS5FWFRFTkQpIHtcbiAgfSBlbHNlIGlmIChyaWdodCA9PT0gRXh0cmFwb2xhdGUuQ0xBTVApIHtcbiAgICBvdXRwdXQgPSBjb25kKFxuICAgICAgZ3JlYXRlclRoYW4odmFsdWUsIGlucHV0UmFuZ2VbaW5wdXRSYW5nZS5sZW5ndGggLSAxXSksXG4gICAgICBvdXRwdXRSYW5nZVtvdXRwdXRSYW5nZS5sZW5ndGggLSAxXSxcbiAgICAgIG91dHB1dFxuICAgICk7XG4gIH0gZWxzZSBpZiAocmlnaHQgPT09IEV4dHJhcG9sYXRlLklERU5USVRZKSB7XG4gICAgb3V0cHV0ID0gY29uZChcbiAgICAgIGdyZWF0ZXJUaGFuKHZhbHVlLCBpbnB1dFJhbmdlW2lucHV0UmFuZ2UubGVuZ3RoIC0gMV0pLFxuICAgICAgdmFsdWUsXG4gICAgICBvdXRwdXRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbiJdfQ==